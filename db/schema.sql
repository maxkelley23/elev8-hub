-- =====================================================
-- ELEV8 HUB - PHASE 1 DATABASE SCHEMA
-- =====================================================
-- This file contains the complete database schema for Phase 1
-- Run this in your Supabase SQL Editor to set up all tables
-- =====================================================

-- Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =====================================================
-- TABLE: campaigns
-- =====================================================
-- Stores campaign data generated by the Campaign Generator
-- Each campaign represents a complete email/LinkedIn outreach strategy
-- =====================================================

CREATE TABLE IF NOT EXISTS campaigns (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  -- Basic campaign info
  title TEXT NOT NULL,
  segment TEXT NOT NULL, -- Target audience segment (e.g., "HVAC Owners", "Realtors")
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'archived', 'deleted')),

  -- Campaign metadata
  created_by UUID, -- Future: reference to auth.users when auth is added
  version INT NOT NULL DEFAULT 1, -- Track campaign versions

  -- Campaign JSON specification (contains all campaign details)
  -- Structure: { icp: {...}, messages: [...], cadence: {...}, objections: [...] }
  json_spec JSONB NOT NULL,

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_campaigns_status ON campaigns(status);
CREATE INDEX IF NOT EXISTS idx_campaigns_segment ON campaigns(segment);
CREATE INDEX IF NOT EXISTS idx_campaigns_created_at ON campaigns(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_campaigns_created_by ON campaigns(created_by);

-- Trigger to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_campaigns_updated_at
  BEFORE UPDATE ON campaigns
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- TABLE: exports
-- =====================================================
-- Stores export history and generated files
-- Tracks all exports (Instantly CSV, LinkedIn CSV, etc.)
-- =====================================================

CREATE TABLE IF NOT EXISTS exports (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  -- Campaign reference
  campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,

  -- Export details
  target TEXT NOT NULL CHECK (target IN ('instantly', 'linkedin', 'custom')),
  format TEXT NOT NULL DEFAULT 'csv' CHECK (format IN ('csv', 'json', 'xlsx')),

  -- File storage
  file_path TEXT, -- Path to file in storage (future: Supabase Storage)
  file_content TEXT, -- Inline CSV/text content for immediate download
  file_size INT, -- File size in bytes

  -- Export metadata
  row_count INT, -- Number of rows/records in export
  notes TEXT, -- Optional notes about this export

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_exports_campaign_id ON exports(campaign_id);
CREATE INDEX IF NOT EXISTS idx_exports_target ON exports(target);
CREATE INDEX IF NOT EXISTS idx_exports_created_at ON exports(created_at DESC);

-- =====================================================
-- TABLE: snippets
-- =====================================================
-- Reusable content snippets for campaigns
-- Used to store high-performing content that can be reused
-- =====================================================

CREATE TABLE IF NOT EXISTS snippets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  -- Snippet categorization
  tag TEXT NOT NULL, -- Tag/category (e.g., "subject-line", "cta", "opener")
  segment TEXT NOT NULL, -- Target segment (e.g., "hvac", "realtor", "saas")

  -- Content
  content JSONB NOT NULL, -- Snippet content (text, variables, etc.)

  -- Metadata
  is_active BOOLEAN DEFAULT TRUE,
  performance_score DECIMAL(3,2), -- 0.00 to 1.00 rating
  usage_count INT DEFAULT 0, -- Track how often used
  notes TEXT,

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_snippets_tag ON snippets(tag);
CREATE INDEX IF NOT EXISTS idx_snippets_segment ON snippets(segment);
CREATE INDEX IF NOT EXISTS idx_snippets_is_active ON snippets(is_active);
CREATE INDEX IF NOT EXISTS idx_snippets_performance_score ON snippets(performance_score DESC);

-- Trigger for updated_at
CREATE TRIGGER update_snippets_updated_at
  BEFORE UPDATE ON snippets
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- TABLE: campaign_versions
-- =====================================================
-- Version history for campaigns
-- Stores previous versions when campaigns are edited
-- =====================================================

CREATE TABLE IF NOT EXISTS campaign_versions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  -- Campaign reference
  campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,

  -- Version data
  version INT NOT NULL,
  json_spec JSONB NOT NULL, -- Snapshot of campaign at this version

  -- Change tracking
  changed_by UUID, -- Future: reference to auth.users
  change_notes TEXT, -- Optional notes about what changed

  -- Timestamp
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_campaign_versions_campaign_id ON campaign_versions(campaign_id);
CREATE INDEX IF NOT EXISTS idx_campaign_versions_version ON campaign_versions(version);
CREATE INDEX IF NOT EXISTS idx_campaign_versions_created_at ON campaign_versions(created_at DESC);

-- =====================================================
-- TABLE: api_logs
-- =====================================================
-- Log API calls to Claude/OpenAI for monitoring and debugging
-- Helps track costs and performance
-- =====================================================

CREATE TABLE IF NOT EXISTS api_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  -- API call details
  provider TEXT NOT NULL CHECK (provider IN ('anthropic', 'openai', 'other')),
  model TEXT NOT NULL, -- e.g., "claude-3-5-sonnet-20241022"
  endpoint TEXT NOT NULL, -- e.g., "/messages", "/chat/completions"

  -- Request/Response
  prompt_tokens INT,
  completion_tokens INT,
  total_tokens INT,

  -- Cost tracking (in cents)
  estimated_cost_cents DECIMAL(10,2),

  -- Performance
  latency_ms INT, -- Response time in milliseconds

  -- Status
  status TEXT NOT NULL CHECK (status IN ('success', 'error', 'timeout', 'rate_limit')),
  error_message TEXT,

  -- Context
  campaign_id UUID REFERENCES campaigns(id) ON DELETE SET NULL,
  request_type TEXT, -- e.g., "campaign_generation", "critique", "rewrite"

  -- Timestamp
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_api_logs_provider ON api_logs(provider);
CREATE INDEX IF NOT EXISTS idx_api_logs_status ON api_logs(status);
CREATE INDEX IF NOT EXISTS idx_api_logs_campaign_id ON api_logs(campaign_id);
CREATE INDEX IF NOT EXISTS idx_api_logs_created_at ON api_logs(created_at DESC);

-- =====================================================
-- VIEWS FOR CONVENIENCE
-- =====================================================

-- View: Active campaigns with summary stats
CREATE OR REPLACE VIEW active_campaigns AS
SELECT
  id,
  title,
  segment,
  status,
  version,
  created_at,
  updated_at,
  (json_spec->'icp'->>'title') AS icp_title,
  (json_spec->'cadence'->>'totalDays') AS campaign_duration,
  jsonb_array_length(json_spec->'messages') AS message_count
FROM campaigns
WHERE status IN ('draft', 'active')
ORDER BY updated_at DESC;

-- View: Export summary by campaign
CREATE OR REPLACE VIEW export_summary AS
SELECT
  c.id AS campaign_id,
  c.title AS campaign_title,
  COUNT(e.id) AS total_exports,
  COUNT(CASE WHEN e.target = 'instantly' THEN 1 END) AS instantly_exports,
  COUNT(CASE WHEN e.target = 'linkedin' THEN 1 END) AS linkedin_exports,
  MAX(e.created_at) AS last_export_date
FROM campaigns c
LEFT JOIN exports e ON c.id = e.campaign_id
GROUP BY c.id, c.title;

-- View: API cost summary
CREATE OR REPLACE VIEW api_cost_summary AS
SELECT
  DATE(created_at) AS date,
  provider,
  COUNT(*) AS request_count,
  SUM(total_tokens) AS total_tokens,
  SUM(estimated_cost_cents) / 100.0 AS total_cost_dollars,
  AVG(latency_ms) AS avg_latency_ms,
  COUNT(CASE WHEN status = 'error' THEN 1 END) AS error_count
FROM api_logs
GROUP BY DATE(created_at), provider
ORDER BY date DESC, provider;

-- =====================================================
-- ROW LEVEL SECURITY (RLS)
-- =====================================================
-- Note: RLS is disabled by default for Phase 1
-- Enable when adding authentication in future phases

-- Enable RLS on tables (commented out for Phase 1)
-- ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE exports ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE snippets ENABLE ROW LEVEL SECURITY;

-- Example policies (to be enabled in future):
-- CREATE POLICY "Users can view their own campaigns"
--   ON campaigns FOR SELECT
--   USING (auth.uid() = created_by);

-- =====================================================
-- FUNCTIONS FOR DATA MANAGEMENT
-- =====================================================

-- Function: Archive old campaigns
CREATE OR REPLACE FUNCTION archive_old_campaigns(days_old INT DEFAULT 90)
RETURNS INT AS $$
DECLARE
  archived_count INT;
BEGIN
  UPDATE campaigns
  SET status = 'archived'
  WHERE status = 'draft'
    AND created_at < NOW() - (days_old || ' days')::INTERVAL
    AND id NOT IN (SELECT DISTINCT campaign_id FROM exports);

  GET DIAGNOSTICS archived_count = ROW_COUNT;
  RETURN archived_count;
END;
$$ LANGUAGE plpgsql;

-- Function: Clean up old API logs
CREATE OR REPLACE FUNCTION cleanup_old_api_logs(days_old INT DEFAULT 30)
RETURNS INT AS $$
DECLARE
  deleted_count INT;
BEGIN
  DELETE FROM api_logs
  WHERE created_at < NOW() - (days_old || ' days')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- GRANT PERMISSIONS
-- =====================================================
-- Grant permissions to authenticated users (for when auth is added)

GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;

-- =====================================================
-- SCHEMA COMPLETE
-- =====================================================
-- Run the seed.sql file next to populate initial data
-- =====================================================
